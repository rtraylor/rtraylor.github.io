
		
				Using Boolean Algebra to Find all Maximal Independent Sets in a Graph		
		https://www.themathcitadel.com/using-boolean-algebra-to-find-all-maximal-independent-sets-in-a-graph/
		Tue, 23 Oct 2018 22:18:55 +0000
		admin
		http://www.themathcitadel.com/?p=2608
		
		
				Graph theory may be one of the most widely applicable topics I've seen in mathematics. It's used in chemistry, coding theory, operations research, electrical and network engineering, and so many other places. The subject is mainly credited to have begun with the famous&nbsp; <a title="Seven Bridges of Königsberg" href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Seven Bridges of Königsberg</a>&nbsp;problem posed by Leonard Euler in 1736. Frank Harary should also be credited with his massive work in bringing applications of graph theory to the sciences and engineering with his famous textbook written in 1969.&nbsp;

My own <a href="https://www.themathcitadel.com/vertical-dependency-in-sequences-of-categorical-random-variables/">research</a> forced me to stumble into this area once my &nbsp;research partner, Jason Hathcock, suggested we explore the idea of viewing dependency relations in the sequences of variables we were studying as digraphs. Since then, I've been buried in graph theory texts, finding a wealth of fascinating topics to explore.

Of this article's particular interest is finding all maximally independent sets in a graph using Boolean algebra.&nbsp;
<h2>What's a maximally independent set?</h2>
Firstly, what's an independent set?&nbsp;

<hr>

<em><span style="text-decoration: underline;"><strong>Definition (Independent Set)</strong></span></em><em><span style="text-decoration: underline;">:</span></em> A set of vertices of a graph is independent if no two vertices in the set are adjacent.&nbsp;

<hr>

<a href="http://www.themathcitadel.com/wp-content/uploads/2017/06/sinusoidal-standalone.jpg">
<img class="aligncenter wp-image-545 size-medium" src="http://www.themathcitadel.com/wp-content/uploads/2017/06/sinusoidal-standalone-300x219.jpg" alt="" width="300" height="219"></a>

If we take a look at the digraph above (from our paper on vertical dependence), and look at the underlying graph[note]meaning we remove the directedness[/note], [latex]\{1,6,11\}[/latex] form an independent set, as an example. There are lots more, and of varying sizes. Of particular interest here are&nbsp;<em>maximal independent sets</em>.

<hr>

<em><span style="text-decoration: underline;"><strong>Definition:(Maximal Independent Set):</strong></span></em> An independent set to which no other vertex in the graph can be added to retain the independence property

<hr>

An example from the graph above is [latex]\{2,3,4,5,13\}[/latex]. If we added any other vertex to that set, it would be adjacent to some vertex already in there.&nbsp;

A few notes:

(1) There are many maximal independent sets in a graph, and they may not all have the same cardinality.&nbsp;

(2) Maximal and maximum are not the same thing. An independent set may be a maximal independent set without being the largest independent set in the graph. The largest cardinality among all the maximal independent sets is called the&nbsp;<em>independence number&nbsp;</em>of the graph and is denoted [latex]\beta(G)[/latex].
<h2>Why do we care about maximal independent sets?</h2>
Of the many applications that arise, one in particular is in coding theory. We want to find the largest error correcting codes we can, particularly in internet transmissions that can lose packets. A paper discussing this can be found <a href="https://dl.acm.org/citation.cfm?id=508897">here.</a> (Paywall warning). We've discussed some <a href="https://www.themathcitadel.com/group-theory-xor-and-binary-codes-introducing-coding-theory/">basics</a> of <a href="https://www.themathcitadel.com/theory-of-coding-episode-2-maximum-likelihood-decoding/">coding theory</a> on this site as well. Finding error correcting codes with desirable properties is equivalent to solving the problem of finding maximal independent sets. The purpose of this article isn't to discuss the applications here, but I've learned long ago that no one will keep reading unless I mention at least one application.&nbsp;
<h2>Finding a maximal independent set</h2>
[caption id="attachment_544" align="aligncenter" width="300"]<a href="http://www.themathcitadel.com/wp-content/uploads/2017/06/sqrt-standalone.jpg"><img class="size-medium wp-image-544" src="http://www.themathcitadel.com/wp-content/uploads/2017/06/sqrt-standalone-300x233.jpg" alt="" width="300" height="233"></a> Dependency Graph for a monotonic example[/caption]

Finding a maximal independent set is relatively simple. Start with any vertex [latex]v \in V(G)[/latex]. Add another vertex [latex]u[/latex] that is not adjacent to [latex]v[/latex]. Continue adding vertices that are not adjacent to any already in the set. For a finite graph[note]I'm going to only stick with finite graphs here[/note], this process will terminate and the result will be a maximally independent set.&nbsp;

Will it be one of largest cardinality? Not necessarily.&nbsp;

For example, using one more of our dependency graphs generated by [latex]\alpha(n) = \sqrt{n}[/latex], we can take the order to be 24 as shown, and build a maximal independent set starting with vertex 3. Note that none of vertices 9-15 or 1 can be in the set, since they're all adjacent to vertex 3. Vertex 2 is not adjacent to vertex 3, so we add it into our set: [latex]V = \{2,3\}[/latex]. Now, the next vertex we add can't be adjacent to either 2 or 3, so that rules out 1, 9-15, and 4-8. Grab vertex 16. Now [latex]V = \{2,3,16\}[/latex]. Notice that none of the remaining vertices are adjacent to any of the previous vertices. Continuing this process, we'll get that [latex]V = \{2,3,16,17,18,19,20,21,22,23,24\}[/latex]. Notice that if we add any other vertices to this set, they'll be adjacent to something already in it.&nbsp;
<h2>Finding all Maximal Independent Sets</h2>
We're rarely interested in just finding one maximal independent set. We'd prefer to find them all, and doing it by inspection is not very palatable. The heart of the article is an admittedly not optimal but still interesting way to find all maximal independent sets for reasonably small graphs.&nbsp;

[caption id="attachment_2609" align="aligncenter" width="300"]<a href="http://www.themathcitadel.com/wp-content/uploads/2018/10/SIMPLE-GRAPH.jpg"><img class="wp-image-2609 size-medium" src="http://www.themathcitadel.com/wp-content/uploads/2018/10/SIMPLE-GRAPH-300x198.jpg" alt="" width="300" height="198"></a> Image credit: https://www.geeksforgeeks.org/mathematics-graph-theory-basics/[/caption]

We'll illustrate the method on the 6-node graph above.&nbsp;
<h3>Getting started</h3>
First, we'll assign a Boolean variable to each vertex according to its inclusion in a maximal independent set. For example [latex]A = 1[/latex] implies [latex]A[/latex] is in the maximal independent set. Recall from Boolean algebra that&nbsp;

[latex, display = true] x+y = \left\{\begin{array}{lr}1, &amp; x = 1 \text{ or } y = 1 \text{ or } (x=y=1)\\0,&amp;x=0 \text{ and } y=0\end{array}\right.[/latex]

<i>Remark: [latex]x+y[/latex] is just another way of writing a union. This&nbsp;isn't addition mod 2 here.&nbsp;</i>

[latex, display = true] xy=\left\{\begin{array}{lr}1, &amp; x = 1 =y\\0,&amp;\text{ otherwise}\end{array}\right.[/latex]

What we've done here is set up inclusion into our maximal independent sets in a Boolean fashion. So [latex]x+y = 1[/latex] corresponds to the inclusion of either vertex [latex]x[/latex] OR vertex [latex]y[/latex] OR both vertices [latex]x[/latex] and [latex]y[/latex]. Similarly, [latex]xy = 1[/latex] corresponds to the inclusion of both vertices [latex]x[/latex] and [latex]y[/latex].

Now, we can express an edge of a graph as a Boolean product [latex]xy[/latex], where [latex]x[/latex] and [latex]y[/latex] are the vertices at either end of the edge.&nbsp;

Finally, set up the sum of all edges and call it [latex]\phi[/latex]:

[latex, display = true]\phi = \sum xy \text{ for all } (x,y) \in G[/latex]

For our graph above,

[latex, display = true]\phi = AB + AD + AE + BC + CE + CF + DE + EF [/latex]
<h3>Why did we do this?</h3>
For a vertex to be in an independent set, it can't be adjacent to any other vertices in the set. Put another way, for each edge, we can only have at most one of the vertices that make it up. If we include [latex]A[/latex] in the independent set [latex]V[/latex], then [latex]B[/latex]&nbsp;<em>cannot</em> be in there.&nbsp;

Returning to our [latex]\phi[/latex], note that its value under Boolean algebra can only be 0 or 1. If [latex]\phi = 1[/latex], then at least one edge has both of its vertices "on". This means, only combinations of [latex]A, B, C, D, E, F[/latex] that yield [latex]\phi = 0[/latex] will give us a maximally independent set.&nbsp;
<h3>Solving the problem</h3>
Our goal now is to find all combinations of our Boolean vertex variables that yield [latex]\phi = 0[/latex]. As it turns out, solving this directly is pretty annoying[note]I spent an amount of time I will not confess to trying to do it this way just to see if it could be done this way.[/note]. If we want [latex]\phi = 0[/latex], that's logically equivalent to seeking [latex]\phi^{c} = 1[/latex], where [latex]\phi^{c}[/latex] is the Boolean complement (or negation) of [latex]\phi[/latex].&nbsp;

Recall from Boolean algebra the following[note]These may not be the symbols you're accustomed to. Just replaces with union and intersection and verify for yourself[/note]:

[latex, display = true]\begin{aligned}(xy)^{c}&amp;=x^{c}+y^{c}\\(x+y)^{c} &amp;= x^{c}y^{c}\end{aligned}[/latex]

So, if we take [latex]\phi^{c}[/latex] for our graph above,&nbsp;

[latex, display = true]\begin{aligned}\phi^{c}&amp;=(A^{c}+B^{c})(A^{c}+D^{c})(A^{c}+E^{c})(B^{c}+C^{c})(C^{c}+E^{c})\\&amp;\quad(C^{c}+F^{c})(D^{c}+E^{c})(E^{c}+F^{c})\end{aligned}[/latex]

What does the negation here actually mean? By taking the complement, instead of finding vertices to include, now we're finding vertices to&nbsp;<strong>exclude<em>.&nbsp;</em></strong>When we multiply this expression out, we'll get a sum of terms, where each term is a product of complements of our original Boolean variables. To get [latex]\phi^{c} = 1[/latex], all we need is one of those terms to be 1. To get a term to be 1, all members of the product must themselves be 1, meaning each term gives us a set of variables to&nbsp;<strong>exclude</strong>. Excluding these variables gives us one maximally independent set for each term, so this gives us all the maximally independent sets.&nbsp;

The nice thing about dealing with Boolean arithmetic is that we can program a computer to do this for us. Any time we can invoke a relationship with Boolean algebra, we can enlist a friendly helpful computer.&nbsp;
<h3>Finishing the example</h3>
We'll do it by hand here, because I'm old-school like that. For larger graphs, obviously one would want to enlist some computational help, or just be very patient. We'll remember a few other rules for Boolean algebra before we finish[note]Again, play with these yourself substituting multiplication for intersection and + for union. All these say is that x AND x is just x, x OR x is just x, and x OR (x AND y) = x, since x also includes its intersection with y[/note]:

[latex, display = true]\begin{aligned}xx &amp;=x\\x+x &amp;=x\\x +xy&amp;=x\end{aligned}[/latex]

After an insane amount of tedious Boolean algebra,

[latex, display = true]\phi^{c} = A^{c}C^{c}E^{c}+A^{c}B^{c}E^{c}F^{c}+A^{c}C^{c}D^{c}F^{c}+B^{c}C^{c}D^{c}E^{c}+B^{c}D^{c}E^{c}F^{c}[/latex]

Recall that each term now tell us which sets of vertices to&nbsp;<em>exclude</em> from a maximal independent set. We negated the question logically. That means we have 5 maximal independent sets:

[latex, display = true]\{B,D,F\}, \{C,D\}, \{B,E\}, \{A,F\}, \{A,C\}[/latex]

We can actually say what the independence number is as well, since we just have to find the maximum cardinality among the sets listed. For this graph, [latex]\beta(G) = 3[/latex].
<h2>Conclusion</h2>
I happened to find this interesting, and ended up obsessed with it for a day, much to the chagrin of my daily planner, which expected me to be working on writing my research monograph. I tried several different ways of solving this beyond the one given. I tried using the direct equation [latex]\phi[/latex], and tried using regular arithmetic on just [latex]\{0,1\}[/latex], setting up a sort-of structure function similar to the <a href="https://www.themathcitadel.com/system-reliability-basics/">reliability block diagrams</a> detailed here.&nbsp;

I always hesitate to blame the method, and rather my own arithmetic errors, but I didn't have much luck with the structure-function method, though I may try again to see if it's an equivalent method. I believe it should be.&nbsp;

Looking at [latex]\phi^{c}[/latex] makes more sense after playing with this problem for some hours. The sum/union is quite nice, because it neatly separates out the various sets to exclude. It's a better exploitation of Boolean algebra than trying to work with [latex]\phi[/latex] but aiming for a sum of 0. I still think it should be possible to work with it directly, even if not advisable. If I decide to torture myself with it further, and end up with something to write about, perhaps I'll append here.

I always end up ending my articles with some takeaway. I don't have much of one here, except it was a curiosity worth sharing. Perhaps a decent takeaway is to reveal a bit of the tedium and dead-ends mathematicians can run into when exploring something. That's just part of research and understanding. It's entirely possible to spend hours, days, weeks on something and all you conclude is that the original method you saw is definitely superior than the one you were trying to develop.&nbsp;		
		
						
		2608
		2018-10-23 22:18:55
		2018-10-23 22:18:55
		closed
		open
		using-boolean-algebra-to-find-all-maximal-independent-sets-in-a-graph
		publish
		0
		0
		post
		
		0
										Algebra
		Applied Math
		Graph Theory
		Spines
						
		_da_attachments
		a:0:{}
		
							
		_edit_last
		2
		
							
		_wp_page_template
		default
		
							
		_acp_button_style
		2
		
							
		_acp_loading_type
		1
		
							
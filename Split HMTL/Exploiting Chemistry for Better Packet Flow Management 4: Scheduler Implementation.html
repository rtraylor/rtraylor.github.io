
		
				Exploiting Chemistry for Better Packet Flow Management 4: Scheduler Implementation		
		https://www.themathcitadel.com/exploiting-chemistry-for-better-packet-flow-management-4-scheduler-implementation/
		Thu, 17 Jan 2019 14:30:06 +0000
		admin
		http://www.themathcitadel.com/?p=2697
		
		
				This article is the fourth part in a series based on a report reviewing the technical report of Meyer and Tschudin[11] who have extended the notion of an artificial chemistry to an artificial packet chemistry with the intention of exploiting the natural behavior of chemical reactions to design better flow management policies for computer networks. <a href="https://www.themathcitadel.com/exploiting-chemistry-for-better-packet-flow-management-1-introduction/">Part 1 introduced</a> the chemistry foundations necessary for study of this technical report, including the Law of Mass Action. <a href="https://www.themathcitadel.com/exploiting-chemistry-for-better-packet-flow-management-2-formal-model/">Part 2</a> elaborated on the mathematical model of an artificial packet chemistry. <a href="https://www.themathcitadel.com/exploiting-chemistry-for-better-packet-flow-management-3-formal-analysis/">Part 3</a> discussed the various types of mathematical analyses for various queueing questions now available with the expression of a computer network and its flow as an artificial packet chemistry. This part will discuss an actual engineering application of all the ideas discussed thus far--a scheduler and a chemical control plane.
<h2>Implementation of a Scheduler Based on the Law of Mass Action</h2>
Likely, this section will be of greatest interest to network engineers. The authors have indeed designed and implemented a scheduler that utilizes this approach in an elegant fashion. In addition, they discuss a "chemical control plane'' that can automatically be compiled from the abstract model. In another application, they relax the static nature of the network to allow an active networking approach that reshapes the queuing network at run-time. The authors do discuss specifics of implementation, though this article will only briefly touch on it.
<h3>Scheduler</h3>
Each network node/reaction vessel has its own scheduler. The scheduler computes the next occurrence time of each rule [latex]r \in R_{i}[/latex] in its local node (this is equivalent to "serving'' or processing a packet or set of packets for bimolecular reactions) according to the Law of Mass Action. It then will sort the events into a priority queue, wait until the first event occurs, then execute. The main difficulty for a scheduler is to dynamically react and reschedule events properly as packets are added to or drained from its queues. The authors note that an efficient mass action scheduler can be implemented that requires only [latex]O(\log(|\mathcal{R}|))[/latex] time to enqueue or dequeue packets. This is based on the Next Reaction Method[4] of Gibson and Bruck.<span class="Apple-converted-space">&nbsp;</span>

Here we'll recount an explicit example that illustrates the concept. If we return to Figure 1 reproduced below, we can walk through Meyer and Tschudin's scheduler implementation.

&nbsp;

<a href="http://www.themathcitadel.com/wp-content/uploads/2019/01/Screen-Shot-2019-01-09-at-10.52.06-AM.png"><img class="aligncenter size-large wp-image-2668" src="http://www.themathcitadel.com/wp-content/uploads/2019/01/Screen-Shot-2019-01-09-at-10.52.06-AM-1024x446.png" alt="" width="640" height="279"></a>

There are two queues, [latex]X[/latex] and [latex]Y[/latex]. Reaction 1 (Server 1) is bimolecular: [latex]X+Y \rightarrow Z[/latex], so the server pulls packets from two queues to execute the service. Reaction 2 (Server 2) is unimolecular, pulling only from queue [latex]Y[/latex]. If we assume the reaction constants [latex]k_{1} = 1000/(\text{packet}\cdot s)[/latex] and [latex]k_{2} = 1000/\text{s}[/latex], that [latex]X[/latex] begins with two packets in its queue, and [latex]Y[/latex] begins with 3 packets in its queue, then the reaction rates [latex]\nu_{r}[/latex], [latex]r=1,2[/latex] are respectively [latex]\nu_{1} = k_{1}c_{X}c_{Y} = 1000\cdot2\cdot3 = 6000[/latex] and [latex]\nu_{2} = k_{2}c_{Y} = 1000\cdot 3 = 3000[/latex]. The occurrence time is the reciprocal of the reaction rate, so the occurrence times [latex]\tau_{r}[/latex] are respectively [latex]\tau_{1} = \frac{1}{6} ms[/latex] and [latex]\tau_{2} = \frac{1}{3} ms[/latex]. That means the first server executes its action first, extracting packets from both [latex]X[/latex] and [latex]Y[/latex].<span class="Apple-converted-space">&nbsp;</span>

Since the occurrence time of [latex]r_{2}[/latex] is coupled with [latex]r_{1}[/latex] (both servers pull from queue [latex]Y[/latex]), the action of [latex]r_{1}[/latex] requires a rescheduling of [latex]r_{2}[/latex]. After [latex]r_{1}[/latex] pulls a packet each from [latex]X[/latex] and [latex]Y[/latex], there is 1 packet left in [latex]X[/latex] and 2 in [latex]Y[/latex], which means we have to recalculate the rate [latex]\nu_{2} = 1000\cdot 2 = 2000[/latex]. The occurrence time of [latex]r_{2}[/latex] is at ms [latex]\frac{1}{3}[/latex], so its time of execution hasn't arrived. But thanks for [latex]r_{1}[/latex]'s effect, we have to rescale and reschedule the occurrence time of [latex]r_{2}[/latex]. This is done by the following:

[latex, display = true]\tau_{r,\text{new}}-\frac{\nu_{r,\text{new}}}{\nu_{r,\text{old}}}(\tau_{r,\text{old}}-t_{\text{now}}) + t_{\text{now}},[/latex]

where [latex](\tau_{r,\text{old}} -t_{\text{now}})[/latex] is the time remaining between the original execution time and the current time. The multiplier in front is a scaling effect.<span class="Apple-converted-space">&nbsp;</span>

In this example, at [latex]t_{\text{now}} = 1/6 ms[/latex], [latex]r_{2}[/latex] was supposed to go at time [latex]1/3 ms[/latex], but will now be prolonged.<span class="Apple-converted-space">&nbsp;</span>

A note here, I did the math for their specific example, and it seems off. I think the multiplier should be as I've written above. The authors wrote the reciprocal, which prolongs too far. I'll work to contact the authors to verify this.<span class="Apple-converted-space">&nbsp;</span>

There are other timed scheduling algorithms utilized in computer networking, such as Earliest Deadline First, which require tagging each packet with a timestamp. This scheduler does not require such an imposition.<span class="Apple-converted-space">&nbsp;</span>
<h3>The Chemical Control Plane</h3>
Here, the authors describe what they term as a chemical control plane that is intended to avoid the messy necessity of sending packets through a complex queueing network in order to shape packet flow as desired. The control plane takes advantage of concepts in enzymatic chemical reactions in order to control flow. This is a different application than the flow networks discussed thus far (as I understand it).

<a href="http://www.themathcitadel.com/wp-content/uploads/2019/01/chemical-control-plane.png"><img class="aligncenter size-large wp-image-2700" src="http://www.themathcitadel.com/wp-content/uploads/2019/01/chemical-control-plane-1024x551.png" alt="" width="640" height="344"></a>

<span class="Apple-converted-space">&nbsp;</span>

Here the forwarding plane which executes actions is separated from the control plane which will shape the flow of packets in the forwarding plane.<span class="Apple-converted-space">&nbsp;</span>

The chemical control plane will dynamically determine the service rates; the servers do not have them predefined. There are some number of FIFO queues [latex]n[/latex], one for each type of ingress packet flow and they are drained by one server each, representing a unimolecular reaction. In the control plane, each queue is represented by an input species [latex]X_{i}[/latex] and product species [latex]X_{i}^{*}[/latex]. The chemical reaction network lives abstractly in the control plane, which is designed by a traffic engineer and can look like any digraph or network he wishes.<span class="Apple-converted-space">&nbsp;</span>

Here we note the difference here between the prior sections, which dealt with physical flows modeled by a chemical reaction network, and moving the chemical reaction network to an abstract control plane. The queues now are not necessarily physically linked together, but we can choose to couple them abstractly to shape traffic.<span class="Apple-converted-space">&nbsp;</span>

When a packet physically enters one of the queues, the control plane injects one instance of the corresponding molecule species into the abstract network. The scheduler described previously is implemented and eventually an instance of the output species is generated. Once this happens, the corresponding server in the forwarding plane physically processes the packet and dequeues the next. The advantage here is that the abstract molecules in the control plane have no payload, so implementation of this model only requires storing an integer value for each species that keeps track of the number of packets in each queue. This allows analysis of behavior at the design phase.<span class="Apple-converted-space">&nbsp;</span>

In the simplest case, a unimolecular reaction [latex]X \to X^{*}[/latex] in the chemical control plane acts like a low-pass filter to the packet flow, smoothing bursts with high frequency components. If the differential equation [latex]\dot{x} = \lambda-kx[/latex] that approximates a unimolecular reaction is converted to the frequency domain via the Laplace transform, the transfer function [latex]F(s)[/latex] has a cut-off frequency at [latex]k[/latex], the reaction constant:

[latex, display = true]F(s) = \frac{\mu(s)}{\lambda(s)} = \frac{k}{s+k}[/latex]

That is, higher-frequency flows will be attenuated, much like dark glasses do with sunlight. Applying this filter at an ingress point of a network leads to less chaotic traffic patterns, but with a cost of a delay [latex]\frac{1}{k}[/latex] and memory to buffer the packets. Therefore, the mean queue length for this single queue will grow proportionally with the delay and flow rate. That is, [latex]\hat{x} = \frac{\lambda}{k}[/latex].

Another consideration of the LoMA queues described by Meyer and Tschudin that differs from the standard M/M/1 queuing models is that the service rate is ultimately unbounded (for infinite capacity queues/networks), since it is proportional to the queue length. This is undesirable to allow in a network, and thus the authors borrow from biological systems and design an abstract enzymatic reaction to limit the rate of packet flow.

In biological systems, enzymes bind to reactant molecules X, called substrates in order to prevent a particular molecule from reacting immediately. Some amount of enzyme molecules E exist, and they can either exist free-form or bound in a complex (EX). The more enzyme molecules in bound form, the slower the <em>rate&nbsp;</em>of transmission grows for an increasing arrival rate. At equilibrium, the influx and efflux of substrate-enzyme complex molecules are equal according to Kirchoff's Law, so<span class="Apple-converted-space">&nbsp;</span>

[latex, display = true]k_{w}c_{X}c_{E} = k_{s}c_{EX}[/latex]

Take a look at Figure 8 above in the chemical control plane to see this action. The number of enzymes is constant, so [latex]c_{E} + c_{EX} = e_{0}[/latex], which yields the Michaelis-Menten equation, expressing the transmission rate [latex]\mu[/latex] in terms of the queue length [latex]c_{X}[/latex].

[latex, display = true]\mu = \nu_{\max}\frac{c_{X}}{K_{M} + c_{X}},[/latex]

which yields a hyperbolic saturation curve. [latex]\nu_{\max} = k_{s}e_{0}[/latex], and [latex]K_{M} = \frac{k_{s}}{k_{w}}[/latex] and specifies the concentration of [latex]X[/latex] at which half of [latex]\nu_{\max}[/latex] is reached.<span class="Apple-converted-space">&nbsp;</span>

When the queue length at queue [latex]X[/latex] is high, the transmission rate converges to [latex]\nu_{\max}[/latex], and behaves like a normal unimolecular reaction when queue length is short.<span class="Apple-converted-space">&nbsp;</span>

The authors also extend this model to handle dynamic changes to the topology of the queuing network, which means that instances of queues and flow relations can be generated "on the fly,'' as it were. Tschudin[13] has created an executable string and multiset rewriting system called <em>Fraglets</em>&nbsp;that allow for the implementation and running of protocols based on the ideas put forth thus far. They describe in the paper how to implement explicitly the enzymatic rate-limiter in the chemical control plane in Figure 8. In this implementation, rather than flow interactions being static and determined at the design phase, each fraglet (packet) sorts itself into a queue. After a packet is serviced, the header of a fraglet is treated as code, allowing a packet to determine its route comparable to active networking. The relationship between the abstract model and execution layer remains, which allows a mathematical model of the behavior of a Fraglets implementation to be generated automatically, and a queuing network to be design and then realized easily in Fraglets language.<span class="Apple-converted-space">&nbsp;</span>
<h2>Continuation</h2>
The final part of this work will discuss an application of artificial packet chemistry to the implementation of a congestion control algorithm, briefly discuss design motifs, and conclude.&nbsp;
<h2>References</h2>
<div class="page" title="Page 11">
<div class="layoutArea">
<div class="column">
<ol>
 	<li>Dittrich, P., Ziegler, J., and Banzhaf, W. Artificial chemistries - a review. Artificial Life 7(2001), 225–275.</li>
</ol>
</div>
</div>
</div>
<div class="page" title="Page 12">
<div class="layoutArea">
<div class="column">
<ol start="2">
 	<li>Feinburg, M. Complex balancing in general kinetic systems. Archive for Rational Mechanics and Analysis 49 (1972).</li>
 	<li>Gadgil, C., Lee, C., and Othmer, H. A stochastic analysis of first-order reaction networks. Bulletin of Mathematical Biology 67 (2005), 901–946.</li>
 	<li>Gibson, M., and Bruck, J. Effcient stochastic simulation of chemical systems with many species and many channels. Journal of Physical Chemistry 104 (2000), 1876–1889.</li>
 	<li>Gillespie, D. The chemical langevin equation. Journal of Chemical Physics 113 (2000).</li>
 	<li>Gillespie, D. The chemical langevin and fokker-planck equations for the reversible isomerizationreaction. Journal of Physical Chemistry 106 (2002), 5063–5071.</li>
 	<li>Horn, F. On a connexion between stability and graphs in chemical kinetics. Proceedings of the RoyalSociety of London 334 (1973), 299–330.</li>
 	<li>Kamimura, K., Hoshino, H., and Shishikui, Y. Constant delay queuing for jitter-sensitive iptvdistribution on home network. IEEE Global Telecommunications Conference (2008).</li>
 	<li>Laidler, K. Chemical Kinetics. McGraw-Hill, 1950.</li>
 	<li>McQuarrie, D. Stochastic approach to chemical kinetics. Journal of Applied Probability 4 (1967), 413–478.</li>
 	<li>&nbsp;Meyer, T., and Tschudin, C. Flow management in packet networks through interacting queues and law-of-mass-action-scheduling. Technical report, University of Basel.</li>
 	<li>&nbsp;Pocher, H. L., Leung, V., and Gilles, D. An application- and management-based approach to atm scheduling. Telecommunication Systems 12 (1999), 103–122.</li>
 	<li>Tschudin, C. Fraglets- a metabolistic execution model for communication protocols. Proceedings of the 2nd annual symposium on autonomous intelligent networks and systems (2003).</li>
</ol>
</div>
</div>
</div>
<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" rel="license"><img style="border-width: 0;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" alt="Creative Commons License"></a>
This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" rel="license">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.		
		
						
		2697
		2019-01-17 14:30:06
		2019-01-17 14:30:06
		closed
		open
		exploiting-chemistry-for-better-packet-flow-management-4-scheduler-implementation
		publish
		0
		0
		post
		
		0
										Applied Math
		Queuing Theory
						
		_da_attachments
		a:1:{i:2711;a:4:{s:7:"file_id";i:2711;s:9:"file_date";s:19:"2019-01-21 16:01:43";s:12:"file_exclude";b:0;s:12:"file_user_id";i:1;}}
		
							
		_edit_last
		2
		
							
		_wp_page_template
		default
		
							
		_acp_button_style
		2
		
							
		_acp_loading_type
		1
		
							
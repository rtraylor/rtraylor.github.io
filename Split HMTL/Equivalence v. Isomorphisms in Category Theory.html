
		
				Equivalence v. Isomorphisms in Category Theory		
		https://www.themathcitadel.com/equivalence-v-isomorphisms-in-category-theory/
		Mon, 17 Jun 2019 13:37:17 +0000
		admin
		https://www.themathcitadel.com/?p=2862
		
		
				<!-- wp:heading -->
<h2>Introduction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><em>Editor's Note: The article is co-written by Rachel Traylor (The Math Citadel/Marquette University) and Valentin Fadeev (The Open University, UK). Substantial additional review, contributions, and discussions were provided by Matt Kukla and Jason Hathcock. A pdf is available for download at the end of this post.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The biggest challenge we have found in studying category theory is the lack of "concrete" examples to illustrate concepts that aren't themselves highly abstract. This may be due to our more "vulgar" nature as a primarily applied mathematician (from the viewpoint of many academic mathematicians). However, we firmly believe that if category theory wishes to deliver on the promises it makes to help bind many branches of mathematics (and even the sciences) together, it needs a little boring vulgarity sometimes when illustrating concepts as opposed to a never-ending march towards greater abstraction and generality.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perhaps we are better poised than many to do the dirty work of illustrating some of these concepts in a more boring way, on topics so familiar many mathematicians ignore them. For this particular article, we will elaborate on the difference between isomorphic categories and equivalent categories. The difference between the two has a degree of subtlety, but exploring a tangible example involving matrices and finite-dimensional vector spaces really clarified these concepts for us.&nbsp;<br></p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Necessary Definitions</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We will not assume a familiarity with all the terms we will be using, so some definitions for reference are provided here. It is perfectly acceptable to skim these until they are invoked later, then return for further examination. For reference, please see <em>Abstract and Concrete Categories</em> by Adámek, Herrlich, and Strecker (1990).</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote">
<p>
<em><strong>Definition (Category)</strong></em>
</p>
<p>
A <strong>category</strong> is a quadruple [latex]\mathbf{A} = (\mathscr{O}, \text{hom}, \text{id}, \circ)[/latex] that consists of
</p>

<ol>
<li> A class [latex]\mathscr{O}[/latex] whose members are called [latex]\mathbf{A}-[/latex]objects.[note]A class is a generalization of the notion of a set. This concept was created to sidestep issues with Russell's Paradox that sets generate. We couldn't talk about the "set of all sets", or the "set of all vector spaces" without running into a paradox, so we created classes which allow for the creation of a class of all sets with any particular property P. For the purposes of this article, accepting a class as a "bigger set" is sufficient.[/note]</li>

<li> For each pair [latex](A,B)[/latex] of [latex]\mathbf{A}-[/latex]objects, a set [latex]\hom(A,B)[/latex] whose elements are called <em>morphisms</em> from [latex]A[/latex] to [latex]B[/latex]. Denoted [latex]A \xrightarrow{f} B[/latex] or [latex]f: A \to B[/latex]. The collection of all morphisms in [latex]\mathbf{A}[/latex] is denoted [latex]\text{Mor}(\mathbf{A})[/latex].</li>

<li>For each [latex]\mathbf{A}-[/latex]object [latex]A[/latex], there is an <em>identity morphism</em> [latex]A \xrightarrow{id_{A}} A[/latex].</li><li> A <em>composition law</em> that associates with each [latex]\mathbf{A}-[/latex]morphism [latex]A \xrightarrow{f} B[/latex] and [latex]B \xrightarrow{g} C[/latex] an [latex]\mathbf{A}-[/latex]morphism [latex]A \xrightarrow{g \circ f} C[/latex] we call the<em> composite</em> of [latex]f[/latex] and [latex]g[/latex].[note]We first apply f to get into B, then apply g to move into C. Thus we perform compositions right to left.[/note] This composite map [latex]g\circ f[/latex] is subject to the following conditions:</li>

<ul>
<li> Composition is associative. That is, for [latex]A \xrightarrow{f} B[/latex], [latex]B \xrightarrow{g} C[/latex], and [latex]C \xrightarrow{h} D[/latex],&nbsp;</p><p>[latex, display = true] h \circ (g\circ f) = (h \circ g) \circ f.[/latex]</li>

<li> For any morphism [latex]A \xrightarrow{f} B[/latex], [latex]id_{B} \circ f = f[/latex] and [latex]f \circ id_{A} = f[/latex].[note]We just want to make sure that composing with identity morphisms doesn't change anything.[/note]</li>

<li> The sets [latex]\hom(A,B)[/latex] are pairwise-disjoint, meaning that a morphism [latex]f[/latex] cannot belong to [latex]\hom(A,B)[/latex] and [latex]\hom(A',B')[/latex] at the same time. It can only be in one set of morphisms. This condition guarantees each morphism has a unique domain (where we're mapping from) and codomain (where we map to).</li>
</ul>

</ol>

<cite>Abstract and Concrete Categories, Adámek, Herrlich, Strecker (1990)</cite>
</blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>For those who have never seen any category theory at all, it is worth a pause to list a couple examples of categories. We shall only list the ones that of interest to this article. There are many more examples, and many more "types" of categories beyond these.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>[latex]\mathbf{Set}[/latex] is the category of all sets. [latex]\mathscr{O}[/latex] is the class of all sets. (Here a particular set is an object. [latex]\mathbb{N}[/latex] is an object in this category, as is the set of all permutations of the numbers [latex]\{1,2,3\}[/latex]. We don't care about individual elements of these sets. We move from one whole set to another whole set. [latex]\hom(A,B)[/latex] is the set of all functions from set [latex]A[/latex] to set [latex]B[/latex]. [latex]id_{A}[/latex] is just the identity function on a set [latex]A[/latex], and [latex]\circ[/latex] is our standard composition of functions.</li><li>[latex]\mathbf{Vect}[/latex] is the category whose objects are all real vector spaces. Morphisms in this category are linear transformations from one vector space to another, so [latex]\hom(A,B)[/latex] is the set of all linear transformations from vector space [latex]A[/latex] to&nbsp;vector space [latex]B[/latex].[note]Later we'll restrict our attention to only finite dimensional vector spaces.[/note] The identity morphisms are identity transformations, and composition in this category is the standard composition of linear maps.</li></ul>
<!-- /wp:list -->

<!-- wp:image {"id":2907,"align":"center","width":341,"height":352} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://www.themathcitadel.com/wp-content/uploads/2019/06/Screen-Shot-2019-06-16-at-2.17.30-PM-989x1024.png" alt="" class="wp-image-2907" width="341" height="352"/></figure></div>
<!-- /wp:image -->

<!-- wp:list -->
<ul><li>[latex]\mathbf{Mat}[/latex] an interesting category worth spending some time on. Objects here are <em>not</em> matrices, as one might guess. Objects in [latex]\mathbf{Mat}[/latex] are natural numbers. Morphisms are [latex]m \times n[/latex] real-valued matrices. (We can generalize this concept to [latex]\mathbf{Mat}_{R}[/latex], where the entries of the matrices are the elements of a particular specified ring [latex]R[/latex], but let's just stick with real-valued matrices here. Put differently, morphisms take a natural number [latex]m[/latex] "to" a natural number [latex]n[/latex] by assigning it a matrix of dimensions [latex]m \times n[/latex] with real-valued entries. [latex]\hom(m,n)[/latex] is the set of all [latex]m\times n[/latex] real-valued matrices. Structurally, there is only one morphism from [latex]m[/latex] to [latex]n[/latex]. While we can have different [latex]m\times n[/latex] matrices that perform the task of mapping [latex]m[/latex] to [latex]n[/latex], they are structurally equivalent in that they map two natural numbers to the same dimensions. In this category, the identity morphism [latex]id_{m}[/latex] are [latex]m \times m[/latex] identity matrices. Composition in this category is defined by [latex]A \circ B = BA[/latex], where [latex]BA[/latex] is just the usual matrix multiplication. It's worth noting here that a category doesn't require that all morphisms be composable. [latex]\mathbf{Mat}[/latex] provides a nice example of this. We can only multiply matrices when the dimensions are appropriate to do so, which means only certain morphisms are composable. This doesn't violate the definition of a category or associativity, etc. Composition must be associative when composition can be done.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Morphisms allow us to move between objects in a category. If we want to move from one category to another, we'll need the concept of a functor.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong><em>Definition (Functor)</em></strong></p><p>If [latex]\mathbf{A}[/latex] and [latex]\mathbf{B}[/latex] are categories, then a <strong>functor</strong> [latex]F[/latex] from [latex]\mathbf{A}[/latex] to [latex]\mathbf{B}[/latex] is a mapping that assigns to each [latex]\mathbf{A}-[/latex]object [latex]A[/latex] and [latex]\mathbf{B}-[/latex]object [latex]FA[/latex]. It also assigns to each [latex]\mathbf{A}-[/latex]morphism [latex]A \xrightarrow{f} A'[/latex] a [latex]\mathbf{B}[/latex]-morphism [latex]FA \xrightarrow{Ff} FA'[/latex] such that the following conditions hold:</p>
<ol>
<li>[latex]F(f\circ g) = Ff \circ Fg[/latex] (Composition is preserved whenever [latex]f\circ g[/latex] is defined.)
</li>
<li> For every [latex]\mathbf{A}-[/latex]object [latex]A[/latex], [latex]F(id_{A}) = id_{FA}[/latex]. This makes sure the functor maps the identity morphism on [latex]A[/latex] to the identity morphism on the object that [latex]A[/latex] maps to in the category [latex]\mathbf{B}[/latex].</li></ol></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Notationally, we'll see functors written [latex]F: \mathbf{A} \to \mathbf{B}[/latex], or [latex]F(A\xrightarrow{f}B)[/latex], which shows more clearly that functors move objects<em> and</em> morphisms.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Functors themselves can have different properties, that are a bit similar to concepts from studying regular functions (e.g. injectivity, surjectivity). We can also compose functors, and that composite functor is indeed a functor.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><strong>Definition (Isomorphism as a functor)</strong></em></p><p>A functor [latex]F : \mathbf{A} \to \mathbf{B}[/latex] is called an <strong>isomorphism</strong> if there is a functor [latex]\mathbf{G}: \mathbf{B} \to \mathbf{A}[/latex] such that [latex]G \circ F = id_{\mathbf{A}}[/latex] and [latex]F \circ G = id_{\mathbf{B}}[/latex]. </p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Note [latex]id_{\cdot}[/latex] here is the identity functor for a category, not the identity morphism on an object. The identity functor will just take all objects to themselves, and all morphisms to themselves, but the identity functor acts on a category, whereas the identity morphism acts on an object within a category.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p> <em><strong>Definition (Faithful Functor)</strong></em></p><p>A functor is <strong>faithful</strong> if all the hom-set restrictions [latex]F: \hom_{\mathbf{A}}(A,A') \to \hom_{\mathbf{B}}(FA, FA')[/latex] are injective.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Here, this means that if a morphism [latex]f \in \text{hom}_{\mathbf{A}}(A,A')[/latex] maps to [latex]Ff \in \hom_{\mathbf{B}}(FA, FA')[/latex], and another morphism [latex]g \in \hom_{\mathbf{A}}(A,A')[/latex] maps to [latex]Fg \in \hom_{\mathbf{B}}(FA, FA')[/latex] we have that [latex]Ff = Fg[/latex] (the two "target" morphisms are the same), then [latex]f = g[/latex]. This needs to hold for all sets of morphisms between any two objects.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><strong>Definition (Full Functor)</strong></em></p><p>A functor [latex]F[/latex] is <strong>full</strong> if all the hom-set restrictions [latex]F: \hom_{\mathbf{A}}(A,A') \to \hom_{\mathbf{B}}(FA, FA')[/latex] are surjective.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>In other words, for a functor to be full, we need a morphism [latex]g[/latex] in [latex]\hom_{\mathbf{B}}(FA, FA')[/latex] to have a morphism [latex]f[/latex] in [latex]\hom_{\mathbf{A}}(A,A')[/latex] such that [latex]Ff = g[/latex]. [latex]g[/latex] should have a "preimage" under the functor.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><strong>Definition (Isomorphism Dense)</strong></em></p><p>A functor is <strong>isomorphism-dense</strong> if for any [latex]\mathbf{B}-[/latex]object [latex]B[/latex] there exists some [latex]\mathbf{A}-[/latex]object [latex]A[/latex] such that [latex]FA \cong B[/latex].&nbsp;</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Two objects [latex]FA[/latex] and [latex]B[/latex] in a category [latex]\mathbf{B}[/latex] are <em>isomorphic</em> if there exists a morphism between the two that is an isomorphism. It is worth clearly noting the definition of an isomorphism at it pertains to morphisms in a category:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><strong>Definition (Isomorphism for Morphisms)</strong></em></p><p>A morphism [latex]f: A \to B[/latex] in a category [latex]\mathbf{A}[/latex] is an isomorphism if there exists a morphism [latex]g: B \to A[/latex] in [latex]\text{Mor}(\mathbf{A})[/latex] such that [latex]f\circ g = id_{B}[/latex] and [latex]g\circ f = id_{A}[/latex] where [latex]id_{A}[/latex] and [latex]id_{B}[/latex] are the identity morphisms for the objects [latex]A[/latex] and [latex]B[/latex].</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Finally, we can combine a few of these to get the notion of an <em>equivalence</em>:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong><em>Definition (Equivalence}</em></strong></p><p>A functor is an <strong>equivalence</strong> if it is full, faithful, and isomorphism-dense.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>If we re-write the definition of an isomorphism (functor), then an isomorphism is a functor that is full, faithful, and bijective on objects, whereas an equivalence is a functor that is full, faithful, and isomorphism-dense. The only difference between these two is the notion of being bijective on objects v. being isomorphism-dense. An isomorphism is more restrictive than an equivalence in the sense that all&nbsp; isomorphisms are equivalences, but we can exhibit equivalences that are not isomorphisms. When we talk about categories being either equivalent or isomorphic, these two words are not interchangeable. In the next sections, we'll discuss this difference, and illustrate with an explicit example.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Linear Algebra and Matrices</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>At this point, we'll revisit briefly some standard results from linear algebra, focusing on real vector spaces. In most undergraduate linear algebra courses, the notion that a linear transformation can be represented in matrix form is simply stated (sometimes proven, but not often). In particular, those linear algebra courses designed for engineers may only focus on linear systems of equations (which are linear transformations) and omit much talk of linear transformations at all. I then consider it reasonable to revisit some of these ideas. For more details, please consult your favorite linear algebra text.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Linear Spaces (Vector Spaces)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><em>Remark: The terms linear space and vector space are interchangeable. Different texts will use different terms.</em></p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong><em>Definition (Linear Space)</em></strong></p><p>A <strong>linear space</strong> over a field [latex]\mathbb{F}[/latex] is a set of elements (vectors) [latex]V[/latex] with two operations [latex]+, \cdot[/latex]. The operation [latex]+[/latex] is called <strong>vector addition</strong> takes two elements [latex]v, w \in V[/latex] and returns another element [latex]v+w \in V[/latex]. The operation [latex]\cdot[/latex] is scalar multiplication, and takes a scalar element [latex]\alpha[/latex] from the field [latex]\mathbb{F}[/latex] and multiplies it by an element [latex]v \in V[/latex] and returns a "scaled" element [latex]\alpha v \in V[/latex]. We require <em>closure</em> under linear combinations. For any [latex]\alpha_{1},\alpha_{2},\ldots,\alpha_{n} \in \mathbb{F}[/latex] and [latex]\mathbf{v}_{1}, \mathbf{v}_{2},\ldots,\mathbf{v}_{n} \in V[/latex],<br> [latex, display = true]\sum_{i=1}^{n}\alpha_{i}\mathbf{v}_{i} \in V.[/latex] This is a consolidation of the ten axioms a linear space must satisfy. The expanded axioms are relegated to the appendix.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>We're going to focus on real vector spaces rather than this abstract definition. Real vector spaces have [latex]\mathbb{R}[/latex] as our field (so we multiply vectors by real numbers).&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The vector spaces most often encountered in engineering problems are [latex]\mathbb{R}^{n}[/latex]--the standard [latex]n-[/latex]dimensional real vector spaces on real-valued vectors. (Also known as a standard Euclidean space.)&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now suppose we wish to move from one vector space [latex]V[/latex] to another [latex]W[/latex]. There are many ways we can define such a move, but the one we're interested in are <em>linear transformations</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong><em>Definition (Linear Transformation)</em></strong></p><p>If [latex]V,W[/latex] are linear spaces, then a function [latex]T: V \to W[/latex] is a linear transformation if </p>
<ol>
<li>[latex]T(x+y) = T(x) + T(y)[/latex] for all [latex]x,y \in V[/latex]. If we add two vectors, and then transform the result into the space [latex]W[/latex], it should yield the same vector in [latex]W[/latex] as if we transformed each of [latex]x[/latex] and [latex]y[/latex] into the space [latex]W[/latex], then added them together.
</li>
<li>[latex]T(\alpha x) = \alpha T(x)[/latex] for all [latex]\alpha \in \mathbb{F}[/latex], [latex]x \in V[/latex]. (We can "factor out" scalars.)
</li>
</ol>
</blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>We can take linear transformations from [latex]\mathbb{R}^{m} \to \mathbb{R}^{n}[/latex] by transforming coordinates as in the following example:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[latex]T:\mathbb{R}^{2} \to \mathbb{R}^{2}[/latex] is given by [latex]T(x) = x+2y[/latex] and [latex]T(y) = 3y[/latex].&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>From linear algebra, we know we may rewrite the transformation in vector form, since we live in "vector space" (in 2 dimensions here):</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[latex, display = true]T\left(\begin{bmatrix}x\\y\end{bmatrix}\right) = \begin{bmatrix}x+2y\\3y\end{bmatrix}[/latex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Typically the next step in linear algebra is to say that we may represent the transformation [latex]T[/latex] in matrix form such that multiplication of our "source vector" by the matrix yields the result of the linear transformation. For our example, the matrix [latex]A[/latex] corresponding to the linear transformation [latex]T[/latex] is&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[latex , display=true]A = \begin{bmatrix}1 &amp; 2 \\ 0 &amp; 3\end{bmatrix},[/latex] 

so that for [latex]\mathbf{x} = \begin{bmatrix}x\\y\end{bmatrix}[/latex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[latex, display = true]A\mathbf{x} = \begin{bmatrix}x+2y \\ 3y\end{bmatrix}[/latex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At this point, this equivalence between linear transformations and matrix representation (with operation matrix/vector multiplication) is simply stated and expected to be accepted. However, we're going to use the notion of equivalences in category theory to establish this formally.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Moving from <strong>Mat</strong> to <strong>Vect</strong><br></h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As mentioned before, we're going to focus only on finite dimensional vector spaces ([latex]\mathbb{R}^{n}[/latex] for various values of [latex]n[/latex] or other spaces of finite dimension ) and real-valued matrices to keep things simple. These concepts generalize much further, though. Since we're operating on real-valued matrices, we'll be using [latex]\mathbf{Mat}_{\mathbb{R}}[/latex][note]If I changed the values of the matrices to, say, complex numbers, we would be using a totally separate category. Changing the values of the matrices changes the ring and thus denotes a completely separate category of matrices[/note]</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":2908,"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://www.themathcitadel.com/wp-content/uploads/2019/06/Screen-Shot-2019-06-16-at-2.17.49-PM-1024x546.png" alt="" class="wp-image-2908"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>To show the equivalence between[latex]\mathbf{Vect}[/latex] and [latex]\mathbf{Mat}[/latex], we must establish an equivalence functor between the two that allows us to map [latex]\mathbf{Mat}[/latex] to [latex]\mathbf{Vect}[/latex]. We define the functor as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> [latex] F:\mathbf{Mat}\to\mathbf{Vect}[/latex] assigns objects [latex]n[/latex] in [latex]\mathbf{Mat}[/latex] the vector space [latex]\mathbb{R}^{n}[/latex]. Thus, we simply assign a natural number [latex]n[/latex] in [latex]\mathbf{Mat}[/latex] to the corresponding [latex]n[/latex]-dimensional real vector space in [latex]\mathbf{Vect}[/latex], which is an object in [latex]\mathbf{Vect}[/latex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Functors also map morphisms in the source category ([latex]\mathbf{Mat}[/latex] in our case) to morphism in the destination category ([latex]\mathbf{Vect}[/latex] here). Morphisms in [latex]\mathbf{Mat}[/latex] are [latex]m \times n[/latex] matrices with real values. Morphisms in [latex]\mathbf{Vect}[/latex] are linear transformations. Thus, it's natural to have our functor take an [latex]m \times n[/latex] matrix [latex]A[/latex] in[latex]\mathbf{Mat}[/latex] and assign to it the linear map [latex]T[/latex] in [latex]\text{Mor}(\textbf{Vect})[/latex] from [latex]\mathbb{R}^{m} \to \mathbb{R}^{n}[/latex] that takes an [latex]m-[/latex]dimensional vector [latex]\mathbf{x}=\begin{bmatrix}x_{1}\\\vdots \\x_{m}\end{bmatrix} \in \mathbb{R}^{m}[/latex] maps it to the [latex]n-[/latex]dimensional vector [latex]\mathbf{y} = \begin{bmatrix}y_{1}\\\vdots\\y_{n}\end{bmatrix}^{T} \in \mathbb{R}^{n}[/latex] given by [latex]\mathbf{x}^{T}A[/latex].[note]T is transpose here, and we only needed to shift some things (like multiplying on the right) to keep our "direction" matching the m x n matrix dimension and appropriateness of matrix multiplication[/note]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We need to check that this functor satisfies the definition of both a functor and an equivalence. That [latex]F[/latex] is a functor follows from matrix multiplication on one hand, and from composition of linear maps on the other. To ensure it satisfies the definition of an equivalence, we must check to see that the functor is full, faithful, and isomorphism-dense.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To show the functor is faithful, take two linear transformations [latex]T[/latex] and [latex]T'[/latex] in [latex]\mathbf{Vect}[/latex] such that [latex]T = T'[/latex]. In other words, these two transformations do the exact same thing to input vectors. It's clear there can if we had two different matrices [latex]A[/latex] and [latex]A'[/latex] such that multiplication by [latex]\mathbf{x}[/latex] yields the exact same vector [latex]\mathbf{y}[/latex], then [latex]A = A'[/latex]. Thus the functor is indeed faithful. To show the functor is full, we need to show that for any linear transformation [latex]T \in \text{Mor}(\mathbf{Vect})[/latex], there is a matrix [latex]A \in \text{Mor}(\mathbf{Mat})[/latex] such that [latex]F(A) = T[/latex]. A linear transformation by definition (see above) results in a component [latex]x_{i} \in \mathbb{R}^{m}[/latex] being taken to a linear combination of components [latex]x_{j} \in \mathbb{R}^{n}[/latex]. Refer back to the example above, where we mapped from [latex]\mathbb{R}^{2}[/latex] to [latex]\mathbb{R}^{2}[/latex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[latex,display=true]T\left(\begin{bmatrix}x\\y\end{bmatrix}\right) = \begin{bmatrix}x+2y\\3y\end{bmatrix}[/latex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since multiplication of matrices results in components which are linear combinations of the source vector by definition of matrix multiplication, there is certainly a matrix [latex]A \in \text{Mor}(\mathbf{Mat})[/latex] that will map to [latex]T \in \text{Mor}(\mathbf{Vect})[/latex] for any linear transformation [latex]T[/latex]. Thus, [latex]F[/latex] is certainly a full functor.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It remains to show that [latex]F[/latex] is isomorphism-dense. To do so, we're going to attempt to create its "inverse" functor [latex]G : \mathbf{Vect} \to \mathbf{Mat}[/latex]. It is at this point we'll really understand the difference between being isomorphism-dense and being a true isomorphism.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Creating the Inverse Functor</h2>
<!-- /wp:heading -->

<!-- wp:image {"id":2909,"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://www.themathcitadel.com/wp-content/uploads/2019/06/Screen-Shot-2019-06-16-at-2.17.59-PM-1024x691.png" alt="" class="wp-image-2909"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We're going to create a functor [latex]G[/latex] that maps [latex]\mathbf{Vect}[/latex] to [latex]\mathbf{Mat}[/latex]. For this, we'll define it as the "natural" inverse. [latex]G[/latex] will take vector spaces in [latex]\mathbf{Vect}[/latex] to their dimension [latex]n \in \mathbb{N}[/latex], which is an object in [latex]\mathbf{Mat}[/latex]. We'll also take [latex]T \in \text{Mor}(\mathbf{Vect})[/latex] to its corresponding matrix [latex]A \in \text{Mor}(\mathbf{Mat})[/latex], simply "reversing" the direction.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can show in an identical manner to what we did for [latex]F[/latex] that the functor [latex]G[/latex] is full. Isomorphisms in [latex]\mathbf{Vect}[/latex] are invertible linear maps between vector spaces. Since the objects of [latex]\mathbf{Mat}[/latex] are natural numbers, we cannot have isomorphisms between different objects. That is, [latex]m[/latex] cannot be isomorphic to [latex]n[/latex] inside [latex]\mathbf{Mat}[/latex] unless [latex]m=n[/latex]. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We now illustrate the key difference between isomorphism and isomorphism-dense functors. Take the space of polynomials of order [latex]m[/latex] with real coefficients. This is indeed a real vector space, and belongs to [latex]\mathbf{Vect}[/latex]. This polynomial space is isomorphic to [latex]\mathbb{R}^{m}[/latex] inside of [latex]\mathbf{Vect}[/latex], meaning that there is an invertible linear map [latex]K[/latex] from the polynomial space to [latex]\mathbb{R}^{m}[/latex]. Recall that functors not only map objects to objects, but they also map morphisms to morphisms. Since all the functor [latex]F[/latex] originating [latex]\mathbf{Mat}[/latex] cares about is the dimension of the space, the isomorphism [latex]K[/latex] between the polynomial space and [latex]\mathbb{R}^{m}[/latex] is "invisible" in the category [latex]\mathbf{Mat}[/latex], because [latex]\mathbf{Mat}[/latex] sees the polynomial space and [latex]\mathbb{R}^{m}[/latex] just as "some" [latex]m-[/latex]dimensional spaces. Thus the morphism [latex]K \in \text{Mor}(\textbf{Vect})[/latex] has no morphism in [latex]\text{Mor}(\textbf{Mat})[/latex] that will map to it.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The functor [latex]G[/latex] is not faithful because [latex]T[/latex] and [latex]L[/latex] will map to the same matrix [latex]A_{m\times n}[/latex] in [latex]\text{Mor}(\textbf{Mat})[/latex].&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, the two categories [latex]\mathbf{Vect}[/latex] and [latex]\mathbf{Mat}[/latex] are equivalent, but not isomorphic, because [latex]F[/latex] is only isomorphism-dense, not fully isomorphic.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Conclusion</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We exhibited an explicit example involving the category [latex]\mathbf{Mat}[/latex] of matrices over [latex]\mathbb{R}[/latex] and the category [latex]\mathbf{Vect}[/latex] of finite dimensional real vector spaces to illustrate the difference between functors that are isomorphisms and functors that are equivalences. The key difference is the notion of <em>isomorphism-dense</em>, which means that an object in the target category of a functor may not have a "preimage" in the source space, but is isomorphic inside the target category to an object which does have a "preimage" in the source space.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Appendix</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>For a linear space [latex]V[/latex] over a field [latex]\mathbb{F}[/latex], the following axioms regarding the two operations must be satisfied:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>For [latex]x,y \in V[/latex], [latex]x+y \in V[/latex]. That is, if we perform the addition operation on two elements of [latex]V[/latex], the result can't be outside the set [latex]V[/latex].</li><li>For each [latex]\alpha \in \mathbb{F}[/latex] and [latex]v \in V[/latex], [latex]\alpha v \in V[/latex]. Multiplying an element by a scalar shouldn't "knock" us outside the set [latex]V[/latex].</li><li>For [latex]x,y \in V[/latex], [latex]x+y = y+x[/latex]. (Commutativity)</li><li>For [latex]x,y,z \in V[/latex], [latex]x+(y+z) = (x+y)+z[/latex] (Associativity)</li><li>There must be some element in [latex]V[/latex], denoted [latex]0_{V}[/latex] that is an \textit{additive identity}. That is, for any [latex]x \in V[/latex], [latex]x + 0_{V} = 0_{V} + x = x[/latex].</li><li>For every [latex]x \in V[/latex], the element [latex](-1)x[/latex] has the property that [latex]x + (-1)x = 0_{V}[/latex]. (Existence of "negatives", or additive inverses)</li><li>For [latex]\alpha, \beta \in \mathbb{F}[/latex], [latex]v \in V[/latex], [latex]\alpha(\beta v) = (\alpha\beta)v[/latex]. (Associativity of multiplication)</li><li>For all [latex]x,y \in V[/latex], and for all [latex]\alpha \in \mathbb{F}[/latex], [latex]\alpha(x+y) = \alpha x + \alpha y[/latex] (Distributivity of vector addition)</li><li>For all [latex]\alpha, \beta \in \mathbb{F}[/latex], [latex]v \in V[/latex], [latex](\alpha + \beta)v = \alpha v + \beta v[/latex].[note]Addition of α and β is performed in the field, and may not be the same as vector addition. Vector addition gives a vector. Scalar addition give scalars[/note]</li><li>For every [latex]v \in V[/latex], we have that [latex]1v = v[/latex], where [latex]1[/latex] is the multiplicative identity in [latex]\mathbb{F}[/latex].</li></ol>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Acknowledgements</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We'd like to gratefully acknowledge Matt Kukla and Jason Hathcock for their insights, review, and meaningful discussion.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"linkDestination":"custom"} -->
<figure class="wp-block-image"><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" alt="Creative Commons License"/></a></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</p>
<!-- /wp:paragraph -->		
		
						
		2862
		2019-06-17 13:37:17
		2019-06-17 13:37:17
		closed
		closed
		equivalence-v-isomorphisms-in-category-theory
		publish
		0
		0
		post
		
		0
										Algebra
		Category Theory
						
		_da_attachments
		a:1:{i:2969;a:4:{s:7:"file_id";i:2969;s:9:"file_date";s:19:"2019-06-17 15:15:49";s:12:"file_exclude";b:0;s:12:"file_user_id";i:1;}}
		
							
		_edit_last
		1
		
							
		_acp_button_style
		2
		
							
		_acp_loading_type
		1
		
							